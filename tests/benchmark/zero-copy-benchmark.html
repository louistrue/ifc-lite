<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero-Copy vs Copy Benchmark</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            background: #1a1a2e;
            color: #eee;
            padding: 20px;
        }

        h1 {
            color: #4ecdc4;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            margin-bottom: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .controls {
            background: #16213e;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .controls label {
            display: block;
            margin-bottom: 10px;
        }

        button {
            background: #4ecdc4;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin-right: 10px;
        }

        button:hover {
            background: #3dbdb5;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .benchmark-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .viewer-container {
            background: #16213e;
            border-radius: 8px;
            padding: 15px;
        }

        .viewer-container h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .viewer-container h3 .badge {
            font-size: 10px;
            background: #e74c3c;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }

        .viewer-container h3 .badge.new {
            background: #27ae60;
        }

        canvas {
            width: 100%;
            height: 350px;
            background: #0f0f23;
            border-radius: 4px;
        }

        .stats {
            margin-top: 10px;
            font-size: 13px;
            line-height: 1.6;
        }

        .stats .metric {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid #2a2a4a;
        }

        .stats .metric.highlight {
            background: rgba(78, 205, 196, 0.1);
        }

        .stats .value {
            color: #4ecdc4;
            font-weight: bold;
        }

        .stats .value.better {
            color: #27ae60;
        }

        .stats .value.worse {
            color: #e74c3c;
        }

        .results {
            background: #16213e;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .results h2 {
            color: #4ecdc4;
            margin-bottom: 15px;
        }

        .comparison {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            text-align: center;
        }

        .comparison .card {
            background: #1a1a2e;
            padding: 15px;
            border-radius: 6px;
        }

        .comparison .card h4 {
            color: #888;
            margin-bottom: 5px;
            font-size: 12px;
        }

        .comparison .card .value {
            font-size: 22px;
            color: #4ecdc4;
        }

        .comparison .card .detail {
            font-size: 11px;
            color: #888;
            margin-top: 5px;
        }

        .winner {
            background: #1e4d2b !important;
        }

        .loser {
            background: #4d1e1e !important;
        }

        .memory-chart {
            background: #0f0f23;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }

        .memory-chart h4 {
            color: #4ecdc4;
            margin-bottom: 10px;
        }

        .memory-bar {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .memory-bar .label {
            width: 100px;
            font-size: 12px;
        }

        .memory-bar .bar-container {
            flex: 1;
            background: #2a2a4a;
            height: 20px;
            border-radius: 4px;
            overflow: hidden;
        }

        .memory-bar .bar {
            height: 100%;
            transition: width 0.3s;
        }

        .memory-bar .bar.copy {
            background: #e74c3c;
        }

        .memory-bar .bar.zero-copy {
            background: #27ae60;
        }

        .memory-bar .value {
            width: 80px;
            text-align: right;
            font-size: 12px;
            color: #4ecdc4;
        }

        #log {
            background: #0f0f23;
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
            max-height: 250px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        #log .info {
            color: #4ecdc4;
        }

        #log .warn {
            color: #f39c12;
        }

        #log .error {
            color: #e74c3c;
        }

        #log .success {
            color: #27ae60;
        }

        .info-box {
            background: #0f0f23;
            border-left: 4px solid #4ecdc4;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 13px;
        }

        .info-box h4 {
            color: #4ecdc4;
            margin-bottom: 8px;
        }

        .info-box ul {
            margin-left: 20px;
            color: #aaa;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Zero-Copy vs Traditional Copy Benchmark</h1>
        <p class="subtitle">
            Compares memory copies and performance: Traditional (WASM->JS->GPU) vs Zero-Copy (WASM->GPU direct)
        </p>

        <div class="info-box">
            <h4>What This Measures</h4>
            <ul>
                <li><strong>Traditional:</strong> parseMeshes() -> JS arrays -> coordinate conversion -> separate buffer uploads</li>
                <li><strong>Zero-Copy:</strong> parseToGpuGeometry() -> TypedArray view into WASM -> single interleaved buffer upload</li>
                <li><strong>Memory:</strong> JS heap usage (Chrome only), peak allocation tracking</li>
                <li><strong>Copies:</strong> Estimated data copies based on approach</li>
            </ul>
        </div>

        <div class="controls">
            <label>
                <strong>Select IFC File:</strong>
                <input type="file" id="fileInput" accept=".ifc" data-testid="file-input">
            </label>
            <div style="margin-top: 10px;">
                <button id="runBenchmark" disabled data-testid="run-benchmark">Run Full Benchmark</button>
                <button id="runIterations" disabled data-testid="run-iterations">Run 5 Iterations (Average)</button>
            </div>
            <div style="margin-top: 10px;">
                <label>
                    <input type="checkbox" id="includeRender" checked> Include render loop (50 frames)
                </label>
                <label style="margin-left: 20px;">
                    <input type="checkbox" id="forceGC"> Force GC between tests (if available)
                </label>
            </div>
        </div>

        <div class="benchmark-area">
            <div class="viewer-container">
                <h3>Traditional (Copy) <span class="badge">OLD</span></h3>
                <canvas id="canvasCopy"></canvas>
                <div class="stats" id="statsCopy" data-testid="stats-copy">
                    <div class="metric"><span>Status:</span><span class="value">Ready</span></div>
                </div>
            </div>
            <div class="viewer-container">
                <h3>Zero-Copy <span class="badge new">NEW</span></h3>
                <canvas id="canvasZeroCopy"></canvas>
                <div class="stats" id="statsZeroCopy" data-testid="stats-zero-copy">
                    <div class="metric"><span>Status:</span><span class="value">Ready</span></div>
                </div>
            </div>
        </div>

        <div class="results" id="results" style="display: none;" data-testid="benchmark-results">
            <h2>Performance Comparison</h2>
            <div class="comparison" id="comparison"></div>

            <div class="memory-chart" id="memoryChart">
                <h4>Memory Usage Comparison</h4>
                <div class="memory-bar">
                    <span class="label">Traditional:</span>
                    <div class="bar-container">
                        <div class="bar copy" id="memBarCopy" style="width: 0%"></div>
                    </div>
                    <span class="value" id="memValCopy">-</span>
                </div>
                <div class="memory-bar">
                    <span class="label">Zero-Copy:</span>
                    <div class="bar-container">
                        <div class="bar zero-copy" id="memBarZeroCopy" style="width: 0%"></div>
                    </div>
                    <span class="value" id="memValZeroCopy">-</span>
                </div>
            </div>

            <div id="benchmark-complete" data-testid="benchmark-complete" style="display: none;"></div>
        </div>

        <div id="log"></div>
    </div>

    <script type="module">
        import init, { IfcAPI } from '../../packages/wasm/pkg/ifc-lite.js';

        // Logging
        function log(msg, type = 'info') {
            const logEl = document.getElementById('log');
            const line = document.createElement('div');
            line.className = type;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            logEl.appendChild(line);
            logEl.scrollTop = logEl.scrollHeight;
            console.log(msg);
        }

        // Memory tracking (Chrome only)
        function getMemoryUsage() {
            if (performance.memory) {
                return {
                    usedHeap: performance.memory.usedJSHeapSize,
                    totalHeap: performance.memory.totalJSHeapSize,
                    heapLimit: performance.memory.jsHeapSizeLimit
                };
            }
            return null;
        }

        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        // Try to force GC (Chrome with --js-flags="--expose-gc")
        async function tryForceGC() {
            if (typeof gc !== 'undefined') {
                gc();
                await new Promise(r => setTimeout(r, 100));
                return true;
            }
            // Allocation pressure trick
            const arrays = [];
            for (let i = 0; i < 100; i++) {
                arrays.push(new Uint8Array(1024 * 1024));
            }
            arrays.length = 0;
            await new Promise(r => setTimeout(r, 100));
            return false;
        }

        // Simple WebGL renderer with interleaved support
        class SimpleRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                if (!this.gl) throw new Error('WebGL not supported');

                this.meshes = [];
                this.rotation = 0;
                this.initShaders();
                this.initInterleavedShaders();
            }

            initShaders() {
                const gl = this.gl;

                // Non-interleaved shader (separate position/normal buffers)
                const vsSource = `
                    attribute vec3 aPosition;
                    attribute vec3 aNormal;
                    uniform mat4 uModelView;
                    uniform mat4 uProjection;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vPosition = (uModelView * vec4(aPosition, 1.0)).xyz;
                        vNormal = mat3(uModelView) * aNormal;
                        gl_Position = uProjection * vec4(vPosition, 1.0);
                    }
                `;

                const fsSource = `
                    precision mediump float;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vec3 normal = normalize(vNormal);
                        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                        float diff = max(dot(normal, lightDir), 0.0);
                        vec3 color = vec3(0.7, 0.7, 0.8);
                        gl_FragColor = vec4(color * (0.3 + 0.7 * diff), 1.0);
                    }
                `;

                const vs = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, vsSource);
                gl.compileShader(vs);

                const fs = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fs, fsSource);
                gl.compileShader(fs);

                this.program = gl.createProgram();
                gl.attachShader(this.program, vs);
                gl.attachShader(this.program, fs);
                gl.linkProgram(this.program);

                this.aPosition = gl.getAttribLocation(this.program, 'aPosition');
                this.aNormal = gl.getAttribLocation(this.program, 'aNormal');
                this.uModelView = gl.getUniformLocation(this.program, 'uModelView');
                this.uProjection = gl.getUniformLocation(this.program, 'uProjection');

                gl.enable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
            }

            initInterleavedShaders() {
                const gl = this.gl;

                // Interleaved shader (position + normal in single buffer)
                const vsInterleavedSource = `
                    attribute vec3 aPosition;
                    attribute vec3 aNormal;
                    uniform mat4 uModelView;
                    uniform mat4 uProjection;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vPosition = (uModelView * vec4(aPosition, 1.0)).xyz;
                        vNormal = mat3(uModelView) * aNormal;
                        gl_Position = uProjection * vec4(vPosition, 1.0);
                    }
                `;

                const fsInterleavedSource = `
                    precision mediump float;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    void main() {
                        vec3 normal = normalize(vNormal);
                        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                        float diff = max(dot(normal, lightDir), 0.0);
                        vec3 color = vec3(0.4, 0.8, 0.6);
                        gl_FragColor = vec4(color * (0.3 + 0.7 * diff), 1.0);
                    }
                `;

                const vs = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vs, vsInterleavedSource);
                gl.compileShader(vs);

                const fs = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fs, fsInterleavedSource);
                gl.compileShader(fs);

                this.interleavedProgram = gl.createProgram();
                gl.attachShader(this.interleavedProgram, vs);
                gl.attachShader(this.interleavedProgram, fs);
                gl.linkProgram(this.interleavedProgram);

                this.interleavedAPosition = gl.getAttribLocation(this.interleavedProgram, 'aPosition');
                this.interleavedANormal = gl.getAttribLocation(this.interleavedProgram, 'aNormal');
                this.interleavedUModelView = gl.getUniformLocation(this.interleavedProgram, 'uModelView');
                this.interleavedUProjection = gl.getUniformLocation(this.interleavedProgram, 'uProjection');
            }

            uploadMesh(positions, normals, indices) {
                const gl = this.gl;

                const posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                const normBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

                const idxBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                this.meshes.push({
                    type: 'separate',
                    posBuffer,
                    normBuffer,
                    idxBuffer,
                    count: indices.length
                });
            }

            uploadInterleavedMesh(interleavedData, indices) {
                const gl = this.gl;

                const interleavedBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, interleavedBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, interleavedData, gl.STATIC_DRAW);

                const idxBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                this.meshes.push({
                    type: 'interleaved',
                    interleavedBuffer,
                    idxBuffer,
                    count: indices.length
                });
            }

            clear() {
                const gl = this.gl;
                for (const mesh of this.meshes) {
                    if (mesh.type === 'separate') {
                        gl.deleteBuffer(mesh.posBuffer);
                        gl.deleteBuffer(mesh.normBuffer);
                    } else {
                        gl.deleteBuffer(mesh.interleavedBuffer);
                    }
                    gl.deleteBuffer(mesh.idxBuffer);
                }
                this.meshes = [];
            }

            render(rotate = true) {
                const gl = this.gl;
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;

                this.canvas.width = width;
                this.canvas.height = height;
                gl.viewport(0, 0, width, height);

                gl.clearColor(0.06, 0.06, 0.14, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                if (this.meshes.length === 0) return;

                // Perspective projection
                const fov = 45 * Math.PI / 180;
                const aspect = width / height;
                const near = 0.1;
                const far = this.boundingRadius * 10 || 100000;
                const f = 1.0 / Math.tan(fov / 2);
                const projection = new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (far + near) / (near - far), -1,
                    0, 0, (2 * far * near) / (near - far), 0
                ]);

                // Camera orbit
                if (rotate) this.rotation += 0.02;
                const distance = this.boundingRadius * 2.5 || 100;
                const camX = Math.sin(this.rotation) * distance;
                const camZ = Math.cos(this.rotation) * distance;
                const camY = distance * 0.5;

                const cx = this.center?.[0] || 0;
                const cy = this.center?.[1] || 0;
                const cz = this.center?.[2] || 0;

                const eye = [camX + cx, camY + cy, camZ + cz];
                const target = [cx, cy, cz];
                const up = [0, 1, 0];

                const zAxis = normalize([eye[0] - target[0], eye[1] - target[1], eye[2] - target[2]]);
                const xAxis = normalize(cross(up, zAxis));
                const yAxis = cross(zAxis, xAxis);

                const modelView = new Float32Array([
                    xAxis[0], yAxis[0], zAxis[0], 0,
                    xAxis[1], yAxis[1], zAxis[1], 0,
                    xAxis[2], yAxis[2], zAxis[2], 0,
                    -dot(xAxis, eye), -dot(yAxis, eye), -dot(zAxis, eye), 1
                ]);

                for (const mesh of this.meshes) {
                    if (mesh.type === 'separate') {
                        gl.useProgram(this.program);
                        gl.uniformMatrix4fv(this.uProjection, false, projection);
                        gl.uniformMatrix4fv(this.uModelView, false, modelView);

                        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.posBuffer);
                        gl.enableVertexAttribArray(this.aPosition);
                        gl.vertexAttribPointer(this.aPosition, 3, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.normBuffer);
                        gl.enableVertexAttribArray(this.aNormal);
                        gl.vertexAttribPointer(this.aNormal, 3, gl.FLOAT, false, 0, 0);
                    } else {
                        gl.useProgram(this.interleavedProgram);
                        gl.uniformMatrix4fv(this.interleavedUProjection, false, projection);
                        gl.uniformMatrix4fv(this.interleavedUModelView, false, modelView);

                        const stride = 6 * 4; // 6 floats * 4 bytes
                        gl.bindBuffer(gl.ARRAY_BUFFER, mesh.interleavedBuffer);
                        gl.enableVertexAttribArray(this.interleavedAPosition);
                        gl.vertexAttribPointer(this.interleavedAPosition, 3, gl.FLOAT, false, stride, 0);
                        gl.enableVertexAttribArray(this.interleavedANormal);
                        gl.vertexAttribPointer(this.interleavedANormal, 3, gl.FLOAT, false, stride, 3 * 4);
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.idxBuffer);
                    gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_INT, 0);
                }
            }

            computeBounds(positions) {
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                for (let i = 0; i < positions.length; i += 3) {
                    minX = Math.min(minX, positions[i]);
                    minY = Math.min(minY, positions[i + 1]);
                    minZ = Math.min(minZ, positions[i + 2]);
                    maxX = Math.max(maxX, positions[i]);
                    maxY = Math.max(maxY, positions[i + 1]);
                    maxZ = Math.max(maxZ, positions[i + 2]);
                }

                this.center = [(minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2];
                this.boundingRadius = Math.sqrt(
                    Math.pow(maxX - minX, 2) +
                    Math.pow(maxY - minY, 2) +
                    Math.pow(maxZ - minZ, 2)
                ) / 2;
            }

            computeBoundsInterleaved(interleavedData) {
                let minX = Infinity, minY = Infinity, minZ = Infinity;
                let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                // Interleaved format: [px, py, pz, nx, ny, nz, ...]
                for (let i = 0; i < interleavedData.length; i += 6) {
                    minX = Math.min(minX, interleavedData[i]);
                    minY = Math.min(minY, interleavedData[i + 1]);
                    minZ = Math.min(minZ, interleavedData[i + 2]);
                    maxX = Math.max(maxX, interleavedData[i]);
                    maxY = Math.max(maxY, interleavedData[i + 1]);
                    maxZ = Math.max(maxZ, interleavedData[i + 2]);
                }

                this.center = [(minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2];
                this.boundingRadius = Math.sqrt(
                    Math.pow(maxX - minX, 2) +
                    Math.pow(maxY - minY, 2) +
                    Math.pow(maxZ - minZ, 2)
                ) / 2;
            }
        }

        // Math helpers
        function normalize(v) {
            const len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
            return [v[0] / len, v[1] / len, v[2] / len];
        }
        function cross(a, b) {
            return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
        }
        function dot(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        }

        // Z-up to Y-up conversion (for traditional approach)
        function convertZUpToYUp(positions, normals) {
            for (let i = 0; i < positions.length; i += 3) {
                const y = positions[i + 1];
                const z = positions[i + 2];
                positions[i + 1] = z;
                positions[i + 2] = -y;
            }
            for (let i = 0; i < normals.length; i += 3) {
                const ny = normals[i + 1];
                const nz = normals[i + 2];
                normals[i + 1] = nz;
                normals[i + 2] = -ny;
            }
        }

        // Stats display
        function updateStats(id, stats) {
            const el = document.getElementById(id);
            el.innerHTML = Object.entries(stats).map(([k, v]) =>
                `<div class="metric" data-metric="${k.toLowerCase()}"><span>${k}:</span><span class="value">${v}</span></div>`
            ).join('');
            el.setAttribute('data-stats', JSON.stringify(stats));
        }

        // Global state
        let ifcApi = null;
        let wasmMemory = null;
        let fileContent = null;

        // Initialize
        async function initApi() {
            log('Initializing IFC-Lite WASM...');
            await init();
            ifcApi = new IfcAPI();
            wasmMemory = ifcApi.getMemory();
            log('IFC-Lite ready');
            log(`WASM memory buffer size: ${formatBytes(wasmMemory.buffer.byteLength)}`);
        }

        // Traditional benchmark (with copies)
        async function benchmarkTraditional(renderer, includeRender) {
            const results = {
                method: 'Traditional (Copy)',
                copies: 3  // WASM->JS (positions), WASM->JS (normals), JS->GPU
            };

            renderer.clear();

            const memBefore = getMemoryUsage();
            let peakHeap = memBefore?.usedHeap || 0;

            // Parse using traditional parseMeshes()
            const parseStart = performance.now();
            const meshes = ifcApi.parseMeshes(fileContent);
            results.parseTime = performance.now() - parseStart;

            // Track memory after parse
            const memAfterParse = getMemoryUsage();
            if (memAfterParse) {
                peakHeap = Math.max(peakHeap, memAfterParse.usedHeap);
            }

            let totalVerts = 0, totalTris = 0;
            const allPositions = [];
            let dataSize = 0;

            // Upload with separate buffers (traditional approach)
            const uploadStart = performance.now();
            for (let i = 0; i < meshes.length; i++) {
                const mesh = meshes.get(i);

                // These create JS copies from WASM memory
                const positions = new Float32Array(mesh.positions);
                const normals = new Float32Array(mesh.normals);
                const indices = new Uint32Array(mesh.indices);

                dataSize += positions.byteLength + normals.byteLength + indices.byteLength;

                // Coordinate conversion in JS
                convertZUpToYUp(positions, normals);

                if (positions.length > 0) {
                    renderer.uploadMesh(positions, normals, indices);
                    for (let j = 0; j < positions.length; j++) {
                        allPositions.push(positions[j]);
                    }
                    totalVerts += positions.length / 3;
                    totalTris += indices.length / 3;
                }

                // Track peak memory during upload
                if (i % 50 === 0) {
                    const memDuring = getMemoryUsage();
                    if (memDuring) {
                        peakHeap = Math.max(peakHeap, memDuring.usedHeap);
                    }
                }
            }
            results.uploadTime = performance.now() - uploadStart;

            renderer.computeBounds(allPositions);
            results.vertices = totalVerts;
            results.triangles = totalTris;
            results.dataSize = dataSize;

            // Final memory
            const memAfter = getMemoryUsage();
            if (memAfter && memBefore) {
                results.heapGrowth = memAfter.usedHeap - memBefore.usedHeap;
                results.peakHeap = peakHeap;
            }

            // Render loop
            if (includeRender) {
                const renderStart = performance.now();
                const frameCount = 50;
                for (let i = 0; i < frameCount; i++) {
                    renderer.render(true);
                }
                results.renderTime = performance.now() - renderStart;
                results.avgFrameTime = results.renderTime / frameCount;
                results.fps = 1000 / results.avgFrameTime;
            } else {
                renderer.render(false);
                results.renderTime = 0;
            }

            results.totalTime = results.parseTime + results.uploadTime + results.renderTime;
            return results;
        }

        // Zero-copy benchmark
        async function benchmarkZeroCopy(renderer, includeRender) {
            const results = {
                method: 'Zero-Copy',
                copies: 1  // Only WASM->GPU
            };

            renderer.clear();

            const memBefore = getMemoryUsage();
            let peakHeap = memBefore?.usedHeap || 0;

            // Parse to GPU-ready format (interleaved, coordinate-converted in Rust)
            const parseStart = performance.now();
            const gpuGeom = ifcApi.parseToGpuGeometry(fileContent);
            results.parseTime = performance.now() - parseStart;

            // Track memory after parse
            const memAfterParse = getMemoryUsage();
            if (memAfterParse) {
                peakHeap = Math.max(peakHeap, memAfterParse.usedHeap);
            }

            // Zero-copy view creation and upload
            const uploadStart = performance.now();

            // Create TypedArray view directly into WASM memory (NO COPY)
            const vertexView = new Float32Array(
                wasmMemory.buffer,
                gpuGeom.vertexDataPtr,
                gpuGeom.vertexDataLen
            );
            const indexView = new Uint32Array(
                wasmMemory.buffer,
                gpuGeom.indicesPtr,
                gpuGeom.indicesLen
            );

            // Upload single interleaved buffer (single copy: WASM -> GPU)
            renderer.uploadInterleavedMesh(vertexView, indexView);
            renderer.computeBoundsInterleaved(vertexView);

            results.uploadTime = performance.now() - uploadStart;

            results.vertices = gpuGeom.totalVertexCount;
            results.triangles = gpuGeom.totalTriangleCount;
            results.dataSize = gpuGeom.vertexDataByteLength + gpuGeom.indicesByteLength;

            // Free WASM memory
            gpuGeom.free();

            // Final memory
            const memAfter = getMemoryUsage();
            if (memAfter && memBefore) {
                results.heapGrowth = memAfter.usedHeap - memBefore.usedHeap;
                results.peakHeap = peakHeap;
            }

            // Render loop
            if (includeRender) {
                const renderStart = performance.now();
                const frameCount = 50;
                for (let i = 0; i < frameCount; i++) {
                    renderer.render(true);
                }
                results.renderTime = performance.now() - renderStart;
                results.avgFrameTime = results.renderTime / frameCount;
                results.fps = 1000 / results.avgFrameTime;
            } else {
                renderer.render(false);
                results.renderTime = 0;
            }

            results.totalTime = results.parseTime + results.uploadTime + results.renderTime;
            return results;
        }

        // Show comparison results
        function showResults(copyResults, zeroCopyResults) {
            const resultsEl = document.getElementById('results');
            const compEl = document.getElementById('comparison');
            resultsEl.style.display = 'block';

            const metrics = [
                { key: 'parseTime', label: 'Parse Time', unit: 'ms', lowerBetter: true },
                { key: 'uploadTime', label: 'Upload Time', unit: 'ms', lowerBetter: true },
                { key: 'totalTime', label: 'Total Time', unit: 'ms', lowerBetter: true },
                { key: 'copies', label: 'Data Copies', unit: '', lowerBetter: true },
            ];

            let html = '';
            for (const m of metrics) {
                const copyVal = copyResults[m.key] || 0;
                const zeroCopyVal = zeroCopyResults[m.key] || 0;

                const zeroCopyWins = m.lowerBetter ? zeroCopyVal < copyVal : zeroCopyVal > copyVal;
                const improvement = copyVal > 0 ? ((copyVal - zeroCopyVal) / copyVal * 100) : 0;

                html += `
                    <div class="card ${zeroCopyWins ? 'winner' : ''}">
                        <h4>${m.label}</h4>
                        <div class="value">${typeof zeroCopyVal === 'number' && m.key !== 'copies' ? zeroCopyVal.toFixed(1) : zeroCopyVal}${m.unit}</div>
                        <div class="detail">Zero-Copy</div>
                        ${zeroCopyWins && improvement > 0 ? `<div class="detail" style="color: #27ae60;">${improvement.toFixed(0)}% faster</div>` : ''}
                    </div>
                `;
            }
            compEl.innerHTML = html;

            // Memory chart
            if (copyResults.peakHeap && zeroCopyResults.peakHeap) {
                const maxMem = Math.max(copyResults.peakHeap, zeroCopyResults.peakHeap);
                document.getElementById('memBarCopy').style.width = (copyResults.peakHeap / maxMem * 100) + '%';
                document.getElementById('memBarZeroCopy').style.width = (zeroCopyResults.peakHeap / maxMem * 100) + '%';
                document.getElementById('memValCopy').textContent = formatBytes(copyResults.peakHeap);
                document.getElementById('memValZeroCopy').textContent = formatBytes(zeroCopyResults.peakHeap);
            }

            // Mark complete for Playwright
            const completeMarker = document.getElementById('benchmark-complete');
            if (completeMarker) {
                completeMarker.style.display = 'block';
                completeMarker.setAttribute('data-complete', 'true');
                completeMarker.setAttribute('data-results', JSON.stringify({
                    copy: copyResults,
                    zeroCopy: zeroCopyResults,
                    improvement: {
                        parseTime: copyResults.parseTime > 0 ? ((copyResults.parseTime - zeroCopyResults.parseTime) / copyResults.parseTime * 100) : 0,
                        uploadTime: copyResults.uploadTime > 0 ? ((copyResults.uploadTime - zeroCopyResults.uploadTime) / copyResults.uploadTime * 100) : 0,
                        totalTime: copyResults.totalTime > 0 ? ((copyResults.totalTime - zeroCopyResults.totalTime) / copyResults.totalTime * 100) : 0,
                    }
                }));
            }
        }

        // Main
        async function main() {
            const rendererCopy = new SimpleRenderer(document.getElementById('canvasCopy'));
            const rendererZeroCopy = new SimpleRenderer(document.getElementById('canvasZeroCopy'));

            await initApi();

            document.getElementById('fileInput').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                log(`Loading ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)...`);
                fileContent = await file.text();
                log('File loaded');

                document.getElementById('runBenchmark').disabled = false;
                document.getElementById('runIterations').disabled = false;
            });

            document.getElementById('runBenchmark').addEventListener('click', async () => {
                const includeRender = document.getElementById('includeRender').checked;
                const forceGC = document.getElementById('forceGC').checked;

                log('Starting benchmark comparison...');

                // Traditional first
                if (forceGC) {
                    log('Forcing GC before traditional benchmark...');
                    await tryForceGC();
                }

                log('Running Traditional (Copy) benchmark...');
                const copyResults = await benchmarkTraditional(rendererCopy, includeRender);
                updateStats('statsCopy', {
                    'Parse': copyResults.parseTime.toFixed(1) + 'ms',
                    'Upload': copyResults.uploadTime.toFixed(1) + 'ms',
                    'Render': copyResults.renderTime.toFixed(1) + 'ms',
                    'Total': copyResults.totalTime.toFixed(1) + 'ms',
                    'Vertices': copyResults.vertices.toLocaleString(),
                    'Triangles': copyResults.triangles.toLocaleString(),
                    'Data Copies': copyResults.copies,
                    'Peak Heap': copyResults.peakHeap ? formatBytes(copyResults.peakHeap) : 'N/A'
                });
                log(`Traditional: ${copyResults.totalTime.toFixed(1)}ms total`, 'info');

                // Zero-copy next
                if (forceGC) {
                    log('Forcing GC before zero-copy benchmark...');
                    await tryForceGC();
                }

                log('Running Zero-Copy benchmark...');
                const zeroCopyResults = await benchmarkZeroCopy(rendererZeroCopy, includeRender);
                updateStats('statsZeroCopy', {
                    'Parse': zeroCopyResults.parseTime.toFixed(1) + 'ms',
                    'Upload': zeroCopyResults.uploadTime.toFixed(1) + 'ms',
                    'Render': zeroCopyResults.renderTime.toFixed(1) + 'ms',
                    'Total': zeroCopyResults.totalTime.toFixed(1) + 'ms',
                    'Vertices': zeroCopyResults.vertices.toLocaleString(),
                    'Triangles': zeroCopyResults.triangles.toLocaleString(),
                    'Data Copies': zeroCopyResults.copies,
                    'Peak Heap': zeroCopyResults.peakHeap ? formatBytes(zeroCopyResults.peakHeap) : 'N/A'
                });
                log(`Zero-Copy: ${zeroCopyResults.totalTime.toFixed(1)}ms total`, 'success');

                showResults(copyResults, zeroCopyResults);

                const improvement = ((copyResults.totalTime - zeroCopyResults.totalTime) / copyResults.totalTime * 100);
                log(`Overall improvement: ${improvement.toFixed(1)}% faster with zero-copy`, improvement > 0 ? 'success' : 'warn');
            });

            document.getElementById('runIterations').addEventListener('click', async () => {
                const includeRender = document.getElementById('includeRender').checked;
                const forceGC = document.getElementById('forceGC').checked;
                const iterations = 5;

                log(`Running ${iterations} iterations for averaged results...`);

                const copyTotals = { parseTime: 0, uploadTime: 0, renderTime: 0, totalTime: 0 };
                const zeroCopyTotals = { parseTime: 0, uploadTime: 0, renderTime: 0, totalTime: 0 };

                for (let i = 0; i < iterations; i++) {
                    log(`Iteration ${i + 1}/${iterations}...`);

                    if (forceGC) await tryForceGC();
                    const copyResults = await benchmarkTraditional(rendererCopy, includeRender);
                    copyTotals.parseTime += copyResults.parseTime;
                    copyTotals.uploadTime += copyResults.uploadTime;
                    copyTotals.renderTime += copyResults.renderTime;
                    copyTotals.totalTime += copyResults.totalTime;

                    if (forceGC) await tryForceGC();
                    const zeroCopyResults = await benchmarkZeroCopy(rendererZeroCopy, includeRender);
                    zeroCopyTotals.parseTime += zeroCopyResults.parseTime;
                    zeroCopyTotals.uploadTime += zeroCopyResults.uploadTime;
                    zeroCopyTotals.renderTime += zeroCopyResults.renderTime;
                    zeroCopyTotals.totalTime += zeroCopyResults.totalTime;
                }

                // Average
                const copyAvg = {
                    method: 'Traditional (Copy)',
                    copies: 3,
                    parseTime: copyTotals.parseTime / iterations,
                    uploadTime: copyTotals.uploadTime / iterations,
                    renderTime: copyTotals.renderTime / iterations,
                    totalTime: copyTotals.totalTime / iterations,
                };
                const zeroCopyAvg = {
                    method: 'Zero-Copy',
                    copies: 1,
                    parseTime: zeroCopyTotals.parseTime / iterations,
                    uploadTime: zeroCopyTotals.uploadTime / iterations,
                    renderTime: zeroCopyTotals.renderTime / iterations,
                    totalTime: zeroCopyTotals.totalTime / iterations,
                };

                updateStats('statsCopy', {
                    'Parse (avg)': copyAvg.parseTime.toFixed(1) + 'ms',
                    'Upload (avg)': copyAvg.uploadTime.toFixed(1) + 'ms',
                    'Render (avg)': copyAvg.renderTime.toFixed(1) + 'ms',
                    'Total (avg)': copyAvg.totalTime.toFixed(1) + 'ms',
                    'Data Copies': copyAvg.copies,
                });

                updateStats('statsZeroCopy', {
                    'Parse (avg)': zeroCopyAvg.parseTime.toFixed(1) + 'ms',
                    'Upload (avg)': zeroCopyAvg.uploadTime.toFixed(1) + 'ms',
                    'Render (avg)': zeroCopyAvg.renderTime.toFixed(1) + 'ms',
                    'Total (avg)': zeroCopyAvg.totalTime.toFixed(1) + 'ms',
                    'Data Copies': zeroCopyAvg.copies,
                });

                showResults(copyAvg, zeroCopyAvg);

                const improvement = ((copyAvg.totalTime - zeroCopyAvg.totalTime) / copyAvg.totalTime * 100);
                log(`Average improvement over ${iterations} runs: ${improvement.toFixed(1)}% faster with zero-copy`, 'success');
            });

            // Continuous animation
            function animate() {
                if (rendererCopy.meshes.length > 0) {
                    rendererCopy.render(true);
                }
                if (rendererZeroCopy.meshes.length > 0) {
                    rendererZeroCopy.render(true);
                }
                requestAnimationFrame(animate);
            }
            animate();
        }

        main().catch(console.error);
    </script>
</body>

</html>
